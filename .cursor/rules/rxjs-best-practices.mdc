---
name: "RxJS Best Practices"
description: "Reglas y mejores prácticas para el desarrollo con RxJS en Angular"
globs: ["**/*.ts", "**/*.component.ts", "**/*.service.ts"]
alwaysApply: true
---

# RxJS Best Practices

## Gestión de Suscripciones
```typescript
// CORRECTO: Usar el pipe async en el template
@Component({
  template: `<div>{{ datos$ | async }}</div>`
})
export class MiComponente {
  datos$ = this.service.getDatos();
}

// CORRECTO: Usar takeUntil para la limpieza
export class MiComponente implements OnDestroy {
  private destroy$ = new Subject<void>();

  ngOnInit() {
    this.datos$.pipe(
      takeUntil(this.destroy$)
    ).subscribe(datos => {
      // manejo de datos
    });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

## Convenciones de Nomenclatura
- Sufijo `$` para Observables: `datos$`
- Sufijo `Subject` para Subjects: `datosSubject`
- Sufijo `Action` para acciones: `loadAction`

## Operadores
- Usar `pipe()` para encadenar operadores
- Preferir operadores declarativos sobre imperativos
- Usar `switchMap` para cancelar peticiones anteriores
- Usar `mergeMap` para peticiones paralelas
- Usar `concatMap` para peticiones secuenciales

## Error Handling
```typescript
// CORRECTO: Manejo de errores con catchError
this.http.get('/api/datos').pipe(
  catchError(error => {
    console.error('Error:', error);
    return EMPTY;
  })
);
```

## Performance
- Usar `shareReplay()` para compartir resultados
- Implementar `distinctUntilChanged()` para evitar emisiones duplicadas
- Usar `debounceTime()` para throttling de eventos

## Testing
```typescript
// CORRECTO: Testing de Observables
it('should emit correct values', () => {
  const values$ = of(1, 2, 3);
  values$.pipe(
    map(x => x * 2)
  ).subscribe(result => {
    expect(result).toBe(expected);
  });
});
```
